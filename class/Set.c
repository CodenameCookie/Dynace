/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 32 "Set.d"
#include <string.h> 
#include <math.h> 

#include "set1.h" 

#define	CLASS	Set_c
#define	ivType	Set_iv_t

#include "generics.h"

object	Set_c;


#line 53 "Set.c"
typedef struct  _Set_iv_t  {
	int iSize;
	int iNelm;
	NODE * iTab;
	CRITICALSECTION iCS;
}	Set_iv_t;


#line 62 "Set.c"
typedef struct  _Set_cv_t  {
	NODE FNODES;
	CRITICALSECTION cCS;
}	Set_cv_t;

static	Set_cv_t	*Set_cv;


#line 49 "Set.d"
#ifdef PROFILE 
#undef PMETHOD 
#define PMETHOD 
#endif 


#line 55 "Set.d"
LOCAL objrtn Set_Lookup(object self, object luk, int mode, int deep, int type, object value); 

#define LTYPE 0 

#define NODE_BLOCK_SIZE 50 

LOCAL NODE new_node(void) 
{ 
	int i; 
	volatile NODE r; 

	ENTERCRITICALSECTION(Set_cv->cCS); 
	if (!Set_cv->FNODES) { 
		Set_cv->FNODES = Tncalloc(struct NODES, NODE_BLOCK_SIZE); 
		for (i=0 ; i != (NODE_BLOCK_SIZE-1) ; ++i) 
			Set_cv->FNODES[i].next = Set_cv->FNODES + (i + 1); 
		gRegisterMemory(Dynace, Set_cv->FNODES, (long)(sizeof(struct NODES) * NODE_BLOCK_SIZE)); 
	} 
	r = Set_cv->FNODES; 
	Set_cv->FNODES = Set_cv->FNODES->next; 
	LEAVECRITICALSECTION(Set_cv->cCS); 
	return r; 
} 

LOCAL void free_node(NODE i) 
{ 
	ENTERCRITICALSECTION(Set_cv->cCS); 
	i->luk = NULL; 
	i->next = Set_cv->FNODES; 
	Set_cv->FNODES = i; 
	LEAVECRITICALSECTION(Set_cv->cCS); 
} 

PMETHOD objrtn Set_New(object self, int size)
{ 
	object set = oSuper(Set_c, gNew, self)(self); 
	ivType *iv = ivPtr(set); 
	iv->iSize = size; 
	iv->iTab = Tncalloc(NODE, size); 
	INITIALIZECRITICALSECTION(iv->iCS); 
	return set; 
} 

cmeth objrtn Set_cm_gNew(object self)
{ 
	return Set_New(self, 51); 
} 

PMETHOD objrtn Set_copy(object self, int deep)
{ Set_iv_t *iv = GetIVs(Set, self);
	object nobj; 
	ivType *iv2; 
	int i; 

	ENTERCRITICALSECTION(iv->iCS); 
	if (deep < 2) 
		nobj = oSuper(Set_c, gCopy, self)(self); 
	else 
		nobj = oSuper(Set_c, gDeepCopy, self)(self); 
	iv2 = ivPtr(nobj); 

	memset(&iv2->iCS, 0, sizeof iv->iCS); 
	INITIALIZECRITICALSECTION(iv2->iCS); 

	iv2->iSize = iv->iSize; 
	iv2->iTab = Tncalloc(NODE, iv2->iSize); 
	for (i=0 ; i != iv2->iSize ; ++i) { 
		NODE n, n2, p; 

		for (n=iv->iTab[i], p=NULL ; n ; p=n2, n=n->next) { 
			n2 = new_node(); 
			switch (deep) { 
				case 0: 
				default: 
				n2->luk = n->luk; 
				break; 
				case 1: 
				n2->luk = gCopy(n->luk); 
				break; 
				case 2: 
				n2->luk = gDeepCopy(n->luk); 
				break; 
			} 
			n2->next = NULL; 
			if (p) 
				p->next = n2; 
			else 
				iv2->iTab[i] = n2; 
		} 
	} 
	LEAVECRITICALSECTION(iv->iCS); 
	return nobj; 
} 

imeth objrtn Set_im_gCopy(object self)
{ 
	return Set_copy(self, ClassOf(self) != CLASS); 
} 

imeth objrtn Set_im_gDeepCopy(object self)
{ 
	return Set_copy(self, 2); 
} 





imeth int Set_im_gSize(object self)
{ Set_iv_t *iv = GetIVs(Set, self);
	return iv->iNelm; 
} 

PMETHOD objrtn Set_delete(object self, int mode, int entire)
{ Set_iv_t *iv = GetIVs(Set, self);
	int i; 

	ENTERCRITICALSECTION(iv->iCS); 
	for (i=0 ; i != iv->iSize ; ++i) { 
		NODE n, p = iv->iTab[i]; 

		for (; p ; p = n) { 
			if (mode == 1) 
				gDispose(p->luk); 
			else if (mode == 2) 
				gDeepDispose(p->luk); 
			n = p->next; 
			free_node(p); 
		} 
		iv->iTab[i] = NULL; 
	} 
	if (entire) { 
		free(iv->iTab); 
		LEAVECRITICALSECTION(iv->iCS); 
		DELETECRITICALSECTION(iv->iCS); 
		self = oSuper(Set_c, gDispose, self)(self); 
	} else { 
		iv->iNelm = 0; 
		LEAVECRITICALSECTION(iv->iCS); 
	} 
	return self; 
} 

imeth objrtn Set_im_gDispose(object self)
{ 
	return Set_delete(self, 0, 1); 
} 

imeth objrtn Set_im_gDeepDispose(object self)
{ 
	return Set_delete(self, 2, 1); 
} 

imeth objrtn Set_im_gDispose1(object self)
{ 
	return Set_delete(self, 1, 1); 
} 

imeth objrtn Set_im_gDisposeAllNodes(object self)
{ 
	return Set_delete(self, 0, 0); 
} 

imeth objrtn Set_im_gDeepDisposeAllNodes(object self)
{ 
	return Set_delete(self, 2, 0); 
} 

imeth objrtn Set_im_gDisposeAllNodes1(object self)
{ 
	return Set_delete(self, 1, 0); 
} 



imeth objrtn Set_im_gForAll(object self, object (*fun)())
{ Set_iv_t *iv = GetIVs(Set, self);
	int i; 

	ENTERCRITICALSECTION(iv->iCS); 
	for (i=0 ; i != iv->iSize ; ++i) { 
		NODE p = iv->iTab[i], n; 
		object v; 

		for (; p ; p = n) { 
			n = p->next; 
			if (v = (*(object (*)(object))fun)(p->luk)) { 
				LEAVECRITICALSECTION(iv->iCS); 
				return(v); 
			} 
		} 
	} 
	LEAVECRITICALSECTION(iv->iCS); 
	return NULL; 
} 

imeth objrtn Set_im_gFirst(object self)
{ Set_iv_t *iv = GetIVs(Set, self);
	int i; 
	object r; 

	ENTERCRITICALSECTION(iv->iCS); 
	for (i=0 ; i != iv->iSize ; ++i) 
		if (iv->iTab[i]) { 
		r = iv->iTab[i]->luk; 
		LEAVECRITICALSECTION(iv->iCS); 
		return r; 
	} 
	LEAVECRITICALSECTION(iv->iCS); 
	return NULL; 
} 

imeth objrtn Set_im_gStringRep(object self)
{ Set_iv_t *iv = GetIVs(Set, self);
	int i; 
	object s, t; 

	s = oSuper(Set_c, gStringRepValue, self)(self); 
	gAppend(s, (object) "  [\n"); 
	for (i=0 ; i != iv->iSize && !iv->iTab[i] ; ++i); 
	while (i != iv->iSize) { 
		NODE p = iv->iTab[i]; 

		while (++i != iv->iSize && !iv->iTab[i]); 
		while (p) { 
			t = gStringRepValue(p->luk); 
			if ((p = p->next) || i != iv->iSize) 
				vBuild(s, NULL, "\t", t, ",\n", NULL); 
			else 
				vBuild(s, NULL, "\t", t, "\n", NULL); 
			gDispose(t); 
		} 
	} 
	gAppend(s, (object) "]\n"); 
	return s; 
} 





imeth objrtn Set_im_gAdd(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_ADD, 0, LTYPE, NULL); 
} 



imeth objrtn Set_im_gFind(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_FIND, 0, LTYPE, NULL); 
} 



imeth objrtn Set_im_gFindAdd(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_FINDADD, 0, LTYPE, NULL); 
} 



imeth objrtn Set_im_gRemoveObj(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_DELETE, 0, LTYPE, NULL); 
} 



imeth objrtn Set_im_gDisposeObj(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_DELETE, 1, LTYPE, NULL); 
} 



imeth objrtn Set_im_gDeepDisposeObj(object self, object luk)
{ 
	ChkArg(luk, 2); 
	return Set_Lookup(self, luk, HT_DELETE, 2, LTYPE, NULL); 
} 



PMETHOD objrtn Set_deleteGroup(object self, int (*fun)(), int deep)
{ Set_iv_t *iv = GetIVs(Set, self);
	int i; 
	NODE n, lastp, p; 

	ENTERCRITICALSECTION(iv->iCS); 
	for (i=0 ; i != iv->iSize ; ++i) { 
		for (lastp=NULL, p=iv->iTab[i] ; p ; p=n) { 
			n = p->next; 
			if ((*(int (*)(object))fun)(p->luk)) { 
				if (deep == 1) 
					gDispose(p->luk); 
				else if (deep == 2) 
					gDeepDispose(p->luk); 
				if (lastp) 
					lastp->next = n; 
				else 
					iv->iTab[i] = n; 
				free_node(p); 
				--iv->iNelm; 
			} else 
				lastp = p; 
		} 
	} 
	LEAVECRITICALSECTION(iv->iCS); 
	return self; 
} 

imeth objrtn Set_im_gGroupRemove(object self, int (*fun)())
{ 
	return Set_deleteGroup(self, fun, 0); 
} 

imeth objrtn Set_im_gDisposeGroup(object self, int (*fun)())
{ 
	return Set_deleteGroup(self, fun, 1); 
} 

imeth objrtn Set_im_gDeepDisposeGroup(object self, int (*fun)())
{ 
	return Set_deleteGroup(self, fun, 2); 
} 




imeth objrtn Set_im_gResize(object self, int size)
{ Set_iv_t *iv = GetIVs(Set, self);
	NODE *v; 
	int i, sz; 

	ENTERCRITICALSECTION(iv->iCS); 
	v = iv->iTab; 
	sz = iv->iSize; 
	iv->iSize = size; 
	iv->iTab = Tncalloc(NODE, size); 
	iv->iNelm = 0; 
	for (i=0 ; i != sz ; ++i) { 
		NODE n, t; 

		for (n=v[i] ; n ; n = t) { 
			Set_Lookup(self, n->luk, HT_ADD, 0, LTYPE, NULL); 
			t = n->next; 
			free_node(n); 
		} 
	} 
	free(v); 
	LEAVECRITICALSECTION(iv->iCS); 
	return self; 
} 

LOCAL unsigned Set_hash_string(char *s) 
{ 
	register char c = 'a'; 
	double t; 
	register unsigned short k=0; 

	while (*s) 
		k += *s++ ^ c++; 
	t = .6125423371 * k; 
	t = t < 0.0 ? -t : t; 
	return (int) (BIG_INT * (t - floor(t))); 
} 

LOCAL unsigned Set_hash_short(int val) 
{ 
	double t; 

	t = .6125423371 * (unsigned) val; 
	t = t < 0.0 ? -t : t; 
	return (unsigned) (BIG_INT * (t - floor(t))); 
} 

PMETHOD objrtn Set_Lookup(object self, object luk, int mode, int deep, int type, object value)



{ Set_iv_t *iv = GetIVs(Set, self);
	NODE e, laste=NULL, newe; 
	unsigned idx; 
	int i=0; 
	struct _Object_iv_t * volatile ret; 


	if ((double)iv->iSize * .9 < (double)iv->iNelm) { 
		int size = (int)((double)iv->iSize * 1.6); 
		gResize(self, size); 
	} 

	ENTERCRITICALSECTION(iv->iCS); 

	if (type == 2) 
		idx = Set_hash_string((char *) luk) % iv->iSize; 
	else if (type == 3 || type == 4) 
		idx = Set_hash_short(*((int *) luk)) % iv->iSize; 
	else 
		idx = gHash(luk) % iv->iSize; 
	if (idx >= (unsigned) iv->iSize) 
		idx %= iv->iSize; 
	e = iv->iTab[idx]; 
	while (1) { 
		if (e == NULL) { 
			if (mode != HT_ADD && mode != HT_FINDADD) { 
				LEAVECRITICALSECTION(iv->iCS); 
				return(NULL); 
			} 
			e = new_node(); 
			switch (type) { 
				case 0: 
				default: 
				e->luk = luk; 
				break; 
				case 1: 
				e->luk = gNewWithObjObj(ObjectAssociation, luk, value); 
				break; 
				case 2: 
				e->luk = gNewWithStrObj(StringAssociation, (char *) luk, value); 
				break; 



				case 4: 
				e->luk = gNewWithIntObj(IntegerAssociation, *((int *)luk), value); 
				break; 
			} 
			e->next = NULL; 
			if (laste) 
				laste->next = e; 
			else 
				iv->iTab[idx] = e; 
			++iv->iNelm; 
			break; 
		} 
		switch (type) { 
			case 0: 
			i = e->luk == luk ? 0 : gCompare(e->luk, luk); 
			break; 
			case 1: { 
				object t = gKey(e->luk); 
				i = t == luk ? 0 : gCompare(t, luk); 
				break; 
			} 
			case 2: { 
				char *t = gStringKey(e->luk); 
				i = t == (char *) luk ? 0 : strcmp(t, (char *) luk); 
				break; 
			} 
#if 0 
				case 3: { 
				int c = gShortKey(e->luk); 
				if (c == *((int *) luk)) 
					i = 0; 
				else 
					i = c < *((int *) luk) ? -1 : 1; 
				break; 
			} 
#endif 

#line 521 "Set.d"
				case 4: { 
				int c = gIntKey(e->luk); 
				if (c == *((int *) luk)) 
					i = 0; 
				else 
					i = c < *((int *) luk) ? -1 : 1; 
				break; 
			} 
		} 
		if (!i) { 
			if (mode == HT_ADD) { 
				LEAVECRITICALSECTION(iv->iCS); 
				return(NULL); 
			} 
			if (mode == HT_DELETE) { 
				if (deep == 1) 
					gDispose(e->luk); 
				else if (deep == 2) 
					gDeepDispose(e->luk); 
				if (laste) 
					laste->next = e->next; 
				else 
					iv->iTab[idx] = e->next; 
				ret = e->luk; 
				free_node(e); 
				--iv->iNelm; 
				LEAVECRITICALSECTION(iv->iCS); 
				return deep ? self : (object) ret; 
			} 
			break; 
		} else if (i > 0) { 
			if (mode != HT_ADD && mode != HT_FINDADD) { 
				LEAVECRITICALSECTION(iv->iCS); 
				return(NULL); 
			} 
			newe = new_node(); 
			switch (type) { 
				case 0: 
				default: 
				newe->luk = luk; 
				break; 
				case 1: 
				newe->luk = gNewWithObjObj(ObjectAssociation, luk, value); 
				break; 
				case 2: 
				newe->luk = gNewWithStrObj(StringAssociation, (char *) luk, value); 
				break; 



				case 4: 
				newe->luk = gNewWithIntObj(IntegerAssociation, *((int *) luk), value); 
				break; 
			} 
			newe->next = e; 
			if (laste) 
				laste->next = newe; 
			else 
				iv->iTab[idx] = newe; 
			e = newe; 
			++iv->iNelm; 
			break; 
		} else { 
			laste = e; 
			e = e->next; 
		} 
	} 
	ret = e->luk; 
	LEAVECRITICALSECTION(iv->iCS); 
	return (object) ret; 
} 

imeth objrtn Set_im_gSequence(object self)
{ Set_iv_t *iv = GetIVs(Set, self);
	return gNewSetSeq(SetSequence, iv->iSize, iv->iNelm, (void *) iv->iTab); 
} 

static void class_init(void) 
{ 
	INITIALIZECRITICALSECTION(Set_cv->cCS); 
} 

#line 629 "Set.c"

objrtn	Set_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (Set_c) {
		LEAVECRITICALSECTION(cs);
		return Set_c;
	}
	INHIBIT_THREADER;
	Set_c = gNewClass(Class, "Set", sizeof(Set_iv_t), sizeof(Set_cv_t), END);
	cMethodFor(Set, gNewWithInt, Set_New);
	cMethodFor(Set, gNew, Set_cm_gNew);
	iMethodFor(Set, gDeepDisposeObj, Set_im_gDeepDisposeObj);
	iMethodFor(Set, gFindAdd, Set_im_gFindAdd);
	iMethodFor(Set, gDispose1, Set_im_gDispose1);
	iMethodFor(Set, gDeepDisposeGroup, Set_im_gDeepDisposeGroup);
	iMethodFor(Set, gFind, Set_im_gFind);
	iMethodFor(Set, gDisposeObj, Set_im_gDisposeObj);
	iMethodFor(Set, gDisposeAllNodes, Set_im_gDisposeAllNodes);
	iMethodFor(Set, gSize, Set_im_gSize);
	iMethodFor(Set, gDeepDisposeAllNodes, Set_im_gDeepDisposeAllNodes);
	iMethodFor(Set, gFirst, Set_im_gFirst);
	iMethodFor(Set, gRemoveObj, Set_im_gRemoveObj);
	iMethodFor(Set, gDispose, Set_im_gDispose);
	iMethodFor(Set, gForAll, Set_im_gForAll);
	iMethodFor(Set, gSequence, Set_im_gSequence);
	iMethodFor(Set, gDisposeAllNodes1, Set_im_gDisposeAllNodes1);
	iMethodFor(Set, gAdd, Set_im_gAdd);
	iMethodFor(Set, gGCDispose, Set_im_gDispose);
	iMethodFor(Set, gCopy, Set_im_gCopy);
	iMethodFor(Set, gDeepDispose, Set_im_gDeepDispose);
	iMethodFor(Set, gResize, Set_im_gResize);
	iMethodFor(Set, gStringRep, Set_im_gStringRep);
	iMethodFor(Set, gLookup, Set_Lookup);
	iMethodFor(Set, gGroupRemove, Set_im_gGroupRemove);
	iMethodFor(Set, gDeepCopy, Set_im_gDeepCopy);
	iMethodFor(Set, gDisposeGroup, Set_im_gDisposeGroup);

	Set_cv = GetCVs(Set);

	class_init();

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return Set_c;
}



