/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 31 "DateTime.d"
#ifndef __COSMIC__ 
#include <time.h> 
#endif 


#line 34 "DateTime.d"
#ifdef _WIN32 
#include <sys/timeb.h> 
#endif 


#line 37 "DateTime.d"
#include <math.h> 

#define	CLASS	DateTime_c
#define	ivType	DateTime_iv_t

#include "generics.h"

object	DateTime_c;


#line 41 "DateTime.d"
static short *Timemark(short int *v) 
{ 
#if defined(_WIN32) && !defined(__MINGW32__) && !defined(__WINE__) 
	SYSTEMTIME st; 

	GetLocalTime(&st); 
	v[0] = st.wYear; 
	v[1] = st.wMonth; 
	v[2] = st.wDay; 
	v[3] = st.wHour; 
	v[4] = st.wMinute; 
	v[5] = st.wSecond; 
	v[6] = st.wMilliseconds; 
#else 


#line 55 "DateTime.d"
#ifdef PLAN9 
	Tm *a; 
	time_t t; 
	time(&t); 
	a = localtime(t); 
	v[0] = a->year + 1900; 
	v[1] = a->mon + 1; 
	v[2] = a->mday; 
	v[3] = a->hour; 
	v[4] = a->min; 
	v[5] = a->sec; 
	v[6] = 0; 
#else 


#line 68 "DateTime.d"
	struct tm *a; 
	time_t t; 
	time(&t); 
	a = localtime(&t); 
	v[0] = a->tm_year + 1900; 
	v[1] = a->tm_mon + 1; 
	v[2] = a->tm_mday; 
	v[3] = a->tm_hour; 
	v[4] = a->tm_min; 
	v[5] = a->tm_sec; 
	v[6] = 0; 
#endif 


#line 80 "DateTime.d"
#endif 


#line 81 "DateTime.d"
	return v; 
} 

cmeth objrtn DateTime_cm_gNewDateTime(object self, long dt, long tm)
{ 
	object obj = oSuper(DateTime_c, gNew, self)(self); 

	gChangeDateValue(obj, dt); 
	gChangeTimeValue(obj, tm); 

	return obj; 
} 

cmeth objrtn DateTime_cm_gNow(object self)
{ 
	object obj = oSuper(DateTime_c, gNew, self)(self); 
	long dt, tm; 
	short v[7]; 

	Timemark(v); 
	dt = 10000L * (long) v[0] + 100L * (long) v[1] + (long) v[2]; 
	tm = 10000000L * (long) v[3] + 100000L * (long) v[4] + 1000L * (long) v[5] + (long) v[6]; 

	gChangeDateValue(obj, dt); 
	gChangeTimeValue(obj, tm); 

	return obj; 
} 

imeth objrtn DateTime_im_gStringRepValue(object self)
{ 
	object s1 = gFormatDate(self, "%Y-%N-%D"); 
	object s2 = gTimeStringRepValue(self); 

	gAppend(s1, (object) " "); 
	gAppend(s1, s2); 

	gDispose(s2); 

	return s1; 
} 

imeth objrtn DateTime_im_gAddHours(object self, long h)
{ 
	long nt, dif; 
	long ot = gTimeValue(self); 
	long d = h / 24L; 

	h %= 24; 
	if (d) 
		gAddDays(self, d); 
	if (h) 
		oSuper(DateTime_c, gAddHours, self)(self, h); 
	nt = gTimeValue(self); 
	dif = nt - ot; 

	if (h > 0 && dif < 0) 
		gAddDays(self, 1); 
	else if (h < 0 && dif > 0) 
		gAddDays(self, -1); 

	return self; 
} 

imeth objrtn DateTime_im_gAddMinutes(object self, long m)
{ 
	long nt, dif; 
	long ot = gTimeValue(self); 
	long h = m / 60L; 

	m %= 60; 
	if (h) 
		gAddHours(self, h); 
	if (m) 
		oSuper(DateTime_c, gAddMinutes, self)(self, m); 
	nt = gTimeValue(self); 
	dif = nt - ot; 

	if (m > 0 && dif < 0) 
		gAddDays(self, 1); 
	else if (m < 0 && dif > 0) 
		gAddDays(self, -1); 

	return self; 
} 

imeth objrtn DateTime_im_gAddSeconds(object self, long s)
{ 
	long nt, dif; 
	long ot = gTimeValue(self); 
	long m = s / 60L; 

	s %= 60; 
	if (m) 
		gAddMinutes(self, m); 
	if (s) 
		oSuper(DateTime_c, gAddSeconds, self)(self, s); 
	nt = gTimeValue(self); 
	dif = nt - ot; 

	if (s > 0 && dif < 0) 
		gAddDays(self, 1); 
	else if (s < 0 && dif > 0) 
		gAddDays(self, -1); 

	return self; 
} 

imeth objrtn DateTime_im_gAddMilliseconds(object self, long l)
{ 
	long nt, dif; 
	long ot = gTimeValue(self); 
	long s = l / 1000L; 

	l %= 1000; 
	if (s) 
		gAddSeconds(self, s); 
	if (l) 
		oSuper(DateTime_c, gAddMilliseconds, self)(self, l); 
	nt = gTimeValue(self); 
	dif = nt - ot; 

	if (l > 0 && dif < 0) 
		gAddDays(self, 1); 
	else if (l < 0 && dif > 0) 
		gAddDays(self, -1); 

	return self; 
} 

imeth int DateTime_im_gValidDateTime(object self)
{ 
	return gValidDate(self) && gValidTime(self); 
} 

imeth objrtn DateTime_im_gDateTimeValues(object self, long *dt, long *tm)
{ 
	*dt = gDateValue(self); 
	*tm = gTimeValue(self); 
	return self; 
} 

imeth objrtn DateTime_im_gChangeDateTimeValues(object self, long dt, long tm)
{ 
	gChangeDateValue(self, dt); 
	gChangeTimeValue(self, tm); 
	return self; 
} 

PMETHOD objrtn dtDiff(object self, object dt, long *ddr, long *tdr)
{ 
	object dobj, tobj; 
	long dd, td; 

	ChkArgTyp(dt, 2, DateTime); 
	dobj = gNewWithLong(Date, gDateValue(dt)); 
	tobj = gNewWithLong(Time, gTimeValue(dt)); 
	dd = gDifference(self, dobj); 
	td = gTimeDifference(self, tobj); 

	gDispose(dobj); 
	gDispose(tobj); 

	if (dd > 0L && td < 0L) { 
		dd--; 
		td += 86400000L; 
	} else if (dd < 0L && td > 0L) { 
		dd++; 
		td -= 86400000L; 
	} 
	if (ddr) 
		*ddr = dd; 
	if (tdr) 
		*tdr = td; 

	return self; 
} 

imeth int DateTime_im_gHash(object self)
{ 
	double t1, t2; 

	t1 = .6125423371 * (unsigned long) gDateValue(self); 
	t1 = t1 < 0.0 ? -t1 : t1; 

	t2 = t1 + .6125423371 * (unsigned long) gTimeValue(self); 
	t2 = t2 < 0.0 ? -t2 : t2; 

	return (int) (BIG_INT * (t2 - floor(t2))); 
} 

imeth int DateTime_im_gCompare(object self, object obj)
{ 
	long dd, td; 

	ChkArg(obj, 2); 
	dtDiff(self, obj, &dd, &td); 
	if (dd < 0L || td < 0L) 
		return -1; 
	if (dd > 0L || td > 0L) 
		return 1; 
	return 0; 
} 

imeth objrtn DateTime_im_gChangeLongValue(object self, long val)
{ 
	oSuper(DateTime_c, gChangeDateValue, self)(self, val); 
	gChangeTimeValue(self, 0L); 

	return self; 
} 

imeth objrtn DateTime_im_gChangeValue(object self, object from)
{ 
	oSuper(DateTime_c, gChangeDateValue, self)(self, gDateValue(from)); 
	gChangeTimeValue(self, gTimeValue(from)); 
	return self; 
} 

imeth objrtn DateTime_im_gFormatDateTime(object self, char *dtbuf, char *tmbuf)
{ 
	object s1 = gFormatDate(self, dtbuf); 
	object s2 = gFormatTime(self, tmbuf); 

	gAppend(s1, s2); 
	gDispose(s2); 

	return s1; 
} 


#line 346 "DateTime.c"

objrtn	DateTime_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (DateTime_c) {
		LEAVECRITICALSECTION(cs);
		return DateTime_c;
	}
	INHIBIT_THREADER;
	Date_initialize();
	if (DateTime_c)  {
		ENABLE_THREADER;
		LEAVECRITICALSECTION(cs);
		return DateTime_c;
	}
	Time_initialize();
	if (DateTime_c)  {
		ENABLE_THREADER;
		LEAVECRITICALSECTION(cs);
		return DateTime_c;
	}
	DateTime_c = gNewClass(Class, "DateTime", 0, 0, Date, Time, END);
	cMethodFor(DateTime, gNewDateTime, DateTime_cm_gNewDateTime);
	cMethodFor(DateTime, gNow, DateTime_cm_gNow);
	iMethodFor(DateTime, gAddMinutes, DateTime_im_gAddMinutes);
	iMethodFor(DateTime, gAddMilliseconds, DateTime_im_gAddMilliseconds);
	iMethodFor(DateTime, gFormatDateTime, DateTime_im_gFormatDateTime);
	iMethodFor(DateTime, gCompare, DateTime_im_gCompare);
	iMethodFor(DateTime, gChangeDateTimeValues, DateTime_im_gChangeDateTimeValues);
	iMethodFor(DateTime, gChangeLongValue, DateTime_im_gChangeLongValue);
	iMethodFor(DateTime, gAddSeconds, DateTime_im_gAddSeconds);
	iMethodFor(DateTime, gDateTimeDifference, dtDiff);
	iMethodFor(DateTime, gAddHours, DateTime_im_gAddHours);
	iMethodFor(DateTime, gStringRepValue, DateTime_im_gStringRepValue);
	iMethodFor(DateTime, gDateTimeValues, DateTime_im_gDateTimeValues);
	iMethodFor(DateTime, gHash, DateTime_im_gHash);
	iMethodFor(DateTime, gChangeValue, DateTime_im_gChangeValue);
	iMethodFor(DateTime, gValidDateTime, DateTime_im_gValidDateTime);

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return DateTime_c;
}



